// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/config/config.proto

package config

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Config struct {
	Datacenter           string       `protobuf:"bytes,1,opt,name=Datacenter,proto3" json:"Datacenter,omitempty"`
	PrimaryDatacenter    string       `protobuf:"bytes,2,opt,name=PrimaryDatacenter,proto3" json:"PrimaryDatacenter,omitempty"`
	NodeName             string       `protobuf:"bytes,3,opt,name=NodeName,proto3" json:"NodeName,omitempty"`
	SegmentName          string       `protobuf:"bytes,4,opt,name=SegmentName,proto3" json:"SegmentName,omitempty"`
	ACL                  *ACL         `protobuf:"bytes,5,opt,name=ACL,proto3" json:"ACL,omitempty"`
	AutoEncrypt          *AutoEncrypt `protobuf:"bytes,6,opt,name=AutoEncrypt,proto3" json:"AutoEncrypt,omitempty"`
	Gossip               *Gossip      `protobuf:"bytes,7,opt,name=Gossip,proto3" json:"Gossip,omitempty"`
	TLS                  *TLS         `protobuf:"bytes,8,opt,name=TLS,proto3" json:"TLS,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Config) Reset()         { *m = Config{} }
func (m *Config) String() string { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()    {}
func (*Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f7e909880fb5ba3, []int{0}
}
func (m *Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Config.Merge(m, src)
}
func (m *Config) XXX_Size() int {
	return m.Size()
}
func (m *Config) XXX_DiscardUnknown() {
	xxx_messageInfo_Config.DiscardUnknown(m)
}

var xxx_messageInfo_Config proto.InternalMessageInfo

func (m *Config) GetDatacenter() string {
	if m != nil {
		return m.Datacenter
	}
	return ""
}

func (m *Config) GetPrimaryDatacenter() string {
	if m != nil {
		return m.PrimaryDatacenter
	}
	return ""
}

func (m *Config) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *Config) GetSegmentName() string {
	if m != nil {
		return m.SegmentName
	}
	return ""
}

func (m *Config) GetACL() *ACL {
	if m != nil {
		return m.ACL
	}
	return nil
}

func (m *Config) GetAutoEncrypt() *AutoEncrypt {
	if m != nil {
		return m.AutoEncrypt
	}
	return nil
}

func (m *Config) GetGossip() *Gossip {
	if m != nil {
		return m.Gossip
	}
	return nil
}

func (m *Config) GetTLS() *TLS {
	if m != nil {
		return m.TLS
	}
	return nil
}

type Gossip struct {
	Encryption           *GossipEncryption `protobuf:"bytes,1,opt,name=Encryption,proto3" json:"Encryption,omitempty"`
	RetryJoinLAN         []string          `protobuf:"bytes,2,rep,name=RetryJoinLAN,proto3" json:"RetryJoinLAN,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Gossip) Reset()         { *m = Gossip{} }
func (m *Gossip) String() string { return proto.CompactTextString(m) }
func (*Gossip) ProtoMessage()    {}
func (*Gossip) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f7e909880fb5ba3, []int{1}
}
func (m *Gossip) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Gossip) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Gossip.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Gossip) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Gossip.Merge(m, src)
}
func (m *Gossip) XXX_Size() int {
	return m.Size()
}
func (m *Gossip) XXX_DiscardUnknown() {
	xxx_messageInfo_Gossip.DiscardUnknown(m)
}

var xxx_messageInfo_Gossip proto.InternalMessageInfo

func (m *Gossip) GetEncryption() *GossipEncryption {
	if m != nil {
		return m.Encryption
	}
	return nil
}

func (m *Gossip) GetRetryJoinLAN() []string {
	if m != nil {
		return m.RetryJoinLAN
	}
	return nil
}

type GossipEncryption struct {
	Key                  string   `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	VerifyIncoming       bool     `protobuf:"varint,2,opt,name=VerifyIncoming,proto3" json:"VerifyIncoming,omitempty"`
	VerifyOutgoing       bool     `protobuf:"varint,3,opt,name=VerifyOutgoing,proto3" json:"VerifyOutgoing,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GossipEncryption) Reset()         { *m = GossipEncryption{} }
func (m *GossipEncryption) String() string { return proto.CompactTextString(m) }
func (*GossipEncryption) ProtoMessage()    {}
func (*GossipEncryption) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f7e909880fb5ba3, []int{2}
}
func (m *GossipEncryption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GossipEncryption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GossipEncryption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GossipEncryption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GossipEncryption.Merge(m, src)
}
func (m *GossipEncryption) XXX_Size() int {
	return m.Size()
}
func (m *GossipEncryption) XXX_DiscardUnknown() {
	xxx_messageInfo_GossipEncryption.DiscardUnknown(m)
}

var xxx_messageInfo_GossipEncryption proto.InternalMessageInfo

func (m *GossipEncryption) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *GossipEncryption) GetVerifyIncoming() bool {
	if m != nil {
		return m.VerifyIncoming
	}
	return false
}

func (m *GossipEncryption) GetVerifyOutgoing() bool {
	if m != nil {
		return m.VerifyOutgoing
	}
	return false
}

type TLS struct {
	VerifyOutgoing           bool     `protobuf:"varint,1,opt,name=VerifyOutgoing,proto3" json:"VerifyOutgoing,omitempty"`
	VerifyServerHostname     bool     `protobuf:"varint,2,opt,name=VerifyServerHostname,proto3" json:"VerifyServerHostname,omitempty"`
	CipherSuites             string   `protobuf:"bytes,3,opt,name=CipherSuites,proto3" json:"CipherSuites,omitempty"`
	MinVersion               string   `protobuf:"bytes,4,opt,name=MinVersion,proto3" json:"MinVersion,omitempty"`
	PreferServerCipherSuites bool     `protobuf:"varint,5,opt,name=PreferServerCipherSuites,proto3" json:"PreferServerCipherSuites,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *TLS) Reset()         { *m = TLS{} }
func (m *TLS) String() string { return proto.CompactTextString(m) }
func (*TLS) ProtoMessage()    {}
func (*TLS) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f7e909880fb5ba3, []int{3}
}
func (m *TLS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLS.Merge(m, src)
}
func (m *TLS) XXX_Size() int {
	return m.Size()
}
func (m *TLS) XXX_DiscardUnknown() {
	xxx_messageInfo_TLS.DiscardUnknown(m)
}

var xxx_messageInfo_TLS proto.InternalMessageInfo

func (m *TLS) GetVerifyOutgoing() bool {
	if m != nil {
		return m.VerifyOutgoing
	}
	return false
}

func (m *TLS) GetVerifyServerHostname() bool {
	if m != nil {
		return m.VerifyServerHostname
	}
	return false
}

func (m *TLS) GetCipherSuites() string {
	if m != nil {
		return m.CipherSuites
	}
	return ""
}

func (m *TLS) GetMinVersion() string {
	if m != nil {
		return m.MinVersion
	}
	return ""
}

func (m *TLS) GetPreferServerCipherSuites() bool {
	if m != nil {
		return m.PreferServerCipherSuites
	}
	return false
}

type ACL struct {
	Enabled                bool       `protobuf:"varint,1,opt,name=Enabled,proto3" json:"Enabled,omitempty"`
	PolicyTTL              string     `protobuf:"bytes,2,opt,name=PolicyTTL,proto3" json:"PolicyTTL,omitempty"`
	RoleTTL                string     `protobuf:"bytes,3,opt,name=RoleTTL,proto3" json:"RoleTTL,omitempty"`
	TokenTTL               string     `protobuf:"bytes,4,opt,name=TokenTTL,proto3" json:"TokenTTL,omitempty"`
	DownPolicy             string     `protobuf:"bytes,5,opt,name=DownPolicy,proto3" json:"DownPolicy,omitempty"`
	DefaultPolicy          string     `protobuf:"bytes,6,opt,name=DefaultPolicy,proto3" json:"DefaultPolicy,omitempty"`
	EnableKeyListPolicy    bool       `protobuf:"varint,7,opt,name=EnableKeyListPolicy,proto3" json:"EnableKeyListPolicy,omitempty"`
	Tokens                 *ACLTokens `protobuf:"bytes,8,opt,name=Tokens,proto3" json:"Tokens,omitempty"`
	DisabledTTL            string     `protobuf:"bytes,9,opt,name=DisabledTTL,proto3" json:"DisabledTTL,omitempty"`
	EnableTokenPersistence bool       `protobuf:"varint,10,opt,name=EnableTokenPersistence,proto3" json:"EnableTokenPersistence,omitempty"`
	MSPDisableBootstrap    bool       `protobuf:"varint,11,opt,name=MSPDisableBootstrap,proto3" json:"MSPDisableBootstrap,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}   `json:"-"`
	XXX_unrecognized       []byte     `json:"-"`
	XXX_sizecache          int32      `json:"-"`
}

func (m *ACL) Reset()         { *m = ACL{} }
func (m *ACL) String() string { return proto.CompactTextString(m) }
func (*ACL) ProtoMessage()    {}
func (*ACL) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f7e909880fb5ba3, []int{4}
}
func (m *ACL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ACL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ACL.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ACL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ACL.Merge(m, src)
}
func (m *ACL) XXX_Size() int {
	return m.Size()
}
func (m *ACL) XXX_DiscardUnknown() {
	xxx_messageInfo_ACL.DiscardUnknown(m)
}

var xxx_messageInfo_ACL proto.InternalMessageInfo

func (m *ACL) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *ACL) GetPolicyTTL() string {
	if m != nil {
		return m.PolicyTTL
	}
	return ""
}

func (m *ACL) GetRoleTTL() string {
	if m != nil {
		return m.RoleTTL
	}
	return ""
}

func (m *ACL) GetTokenTTL() string {
	if m != nil {
		return m.TokenTTL
	}
	return ""
}

func (m *ACL) GetDownPolicy() string {
	if m != nil {
		return m.DownPolicy
	}
	return ""
}

func (m *ACL) GetDefaultPolicy() string {
	if m != nil {
		return m.DefaultPolicy
	}
	return ""
}

func (m *ACL) GetEnableKeyListPolicy() bool {
	if m != nil {
		return m.EnableKeyListPolicy
	}
	return false
}

func (m *ACL) GetTokens() *ACLTokens {
	if m != nil {
		return m.Tokens
	}
	return nil
}

func (m *ACL) GetDisabledTTL() string {
	if m != nil {
		return m.DisabledTTL
	}
	return ""
}

func (m *ACL) GetEnableTokenPersistence() bool {
	if m != nil {
		return m.EnableTokenPersistence
	}
	return false
}

func (m *ACL) GetMSPDisableBootstrap() bool {
	if m != nil {
		return m.MSPDisableBootstrap
	}
	return false
}

type ACLTokens struct {
	Master                 string                     `protobuf:"bytes,1,opt,name=Master,proto3" json:"Master,omitempty"`
	Replication            string                     `protobuf:"bytes,2,opt,name=Replication,proto3" json:"Replication,omitempty"`
	AgentMaster            string                     `protobuf:"bytes,3,opt,name=AgentMaster,proto3" json:"AgentMaster,omitempty"`
	Default                string                     `protobuf:"bytes,4,opt,name=Default,proto3" json:"Default,omitempty"`
	Agent                  string                     `protobuf:"bytes,5,opt,name=Agent,proto3" json:"Agent,omitempty"`
	ManagedServiceProvider []*ACLServiceProviderToken `protobuf:"bytes,6,rep,name=ManagedServiceProvider,proto3" json:"ManagedServiceProvider,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                   `json:"-"`
	XXX_unrecognized       []byte                     `json:"-"`
	XXX_sizecache          int32                      `json:"-"`
}

func (m *ACLTokens) Reset()         { *m = ACLTokens{} }
func (m *ACLTokens) String() string { return proto.CompactTextString(m) }
func (*ACLTokens) ProtoMessage()    {}
func (*ACLTokens) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f7e909880fb5ba3, []int{5}
}
func (m *ACLTokens) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ACLTokens) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ACLTokens.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ACLTokens) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ACLTokens.Merge(m, src)
}
func (m *ACLTokens) XXX_Size() int {
	return m.Size()
}
func (m *ACLTokens) XXX_DiscardUnknown() {
	xxx_messageInfo_ACLTokens.DiscardUnknown(m)
}

var xxx_messageInfo_ACLTokens proto.InternalMessageInfo

func (m *ACLTokens) GetMaster() string {
	if m != nil {
		return m.Master
	}
	return ""
}

func (m *ACLTokens) GetReplication() string {
	if m != nil {
		return m.Replication
	}
	return ""
}

func (m *ACLTokens) GetAgentMaster() string {
	if m != nil {
		return m.AgentMaster
	}
	return ""
}

func (m *ACLTokens) GetDefault() string {
	if m != nil {
		return m.Default
	}
	return ""
}

func (m *ACLTokens) GetAgent() string {
	if m != nil {
		return m.Agent
	}
	return ""
}

func (m *ACLTokens) GetManagedServiceProvider() []*ACLServiceProviderToken {
	if m != nil {
		return m.ManagedServiceProvider
	}
	return nil
}

type ACLServiceProviderToken struct {
	AccessorID           string   `protobuf:"bytes,1,opt,name=AccessorID,proto3" json:"AccessorID,omitempty"`
	SecretID             string   `protobuf:"bytes,2,opt,name=SecretID,proto3" json:"SecretID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ACLServiceProviderToken) Reset()         { *m = ACLServiceProviderToken{} }
func (m *ACLServiceProviderToken) String() string { return proto.CompactTextString(m) }
func (*ACLServiceProviderToken) ProtoMessage()    {}
func (*ACLServiceProviderToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f7e909880fb5ba3, []int{6}
}
func (m *ACLServiceProviderToken) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ACLServiceProviderToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ACLServiceProviderToken.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ACLServiceProviderToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ACLServiceProviderToken.Merge(m, src)
}
func (m *ACLServiceProviderToken) XXX_Size() int {
	return m.Size()
}
func (m *ACLServiceProviderToken) XXX_DiscardUnknown() {
	xxx_messageInfo_ACLServiceProviderToken.DiscardUnknown(m)
}

var xxx_messageInfo_ACLServiceProviderToken proto.InternalMessageInfo

func (m *ACLServiceProviderToken) GetAccessorID() string {
	if m != nil {
		return m.AccessorID
	}
	return ""
}

func (m *ACLServiceProviderToken) GetSecretID() string {
	if m != nil {
		return m.SecretID
	}
	return ""
}

type AutoEncrypt struct {
	TLS                  bool     `protobuf:"varint,1,opt,name=TLS,proto3" json:"TLS,omitempty"`
	DNSSAN               []string `protobuf:"bytes,2,rep,name=DNSSAN,proto3" json:"DNSSAN,omitempty"`
	IPSAN                []string `protobuf:"bytes,3,rep,name=IPSAN,proto3" json:"IPSAN,omitempty"`
	AllowTLS             bool     `protobuf:"varint,4,opt,name=AllowTLS,proto3" json:"AllowTLS,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AutoEncrypt) Reset()         { *m = AutoEncrypt{} }
func (m *AutoEncrypt) String() string { return proto.CompactTextString(m) }
func (*AutoEncrypt) ProtoMessage()    {}
func (*AutoEncrypt) Descriptor() ([]byte, []int) {
	return fileDescriptor_2f7e909880fb5ba3, []int{7}
}
func (m *AutoEncrypt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutoEncrypt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AutoEncrypt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AutoEncrypt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutoEncrypt.Merge(m, src)
}
func (m *AutoEncrypt) XXX_Size() int {
	return m.Size()
}
func (m *AutoEncrypt) XXX_DiscardUnknown() {
	xxx_messageInfo_AutoEncrypt.DiscardUnknown(m)
}

var xxx_messageInfo_AutoEncrypt proto.InternalMessageInfo

func (m *AutoEncrypt) GetTLS() bool {
	if m != nil {
		return m.TLS
	}
	return false
}

func (m *AutoEncrypt) GetDNSSAN() []string {
	if m != nil {
		return m.DNSSAN
	}
	return nil
}

func (m *AutoEncrypt) GetIPSAN() []string {
	if m != nil {
		return m.IPSAN
	}
	return nil
}

func (m *AutoEncrypt) GetAllowTLS() bool {
	if m != nil {
		return m.AllowTLS
	}
	return false
}

func init() {
	proto.RegisterType((*Config)(nil), "config.Config")
	proto.RegisterType((*Gossip)(nil), "config.Gossip")
	proto.RegisterType((*GossipEncryption)(nil), "config.GossipEncryption")
	proto.RegisterType((*TLS)(nil), "config.TLS")
	proto.RegisterType((*ACL)(nil), "config.ACL")
	proto.RegisterType((*ACLTokens)(nil), "config.ACLTokens")
	proto.RegisterType((*ACLServiceProviderToken)(nil), "config.ACLServiceProviderToken")
	proto.RegisterType((*AutoEncrypt)(nil), "config.AutoEncrypt")
}

func init() { proto.RegisterFile("proto/config/config.proto", fileDescriptor_2f7e909880fb5ba3) }

var fileDescriptor_2f7e909880fb5ba3 = []byte{
	// 781 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x55, 0xd1, 0x6e, 0xd3, 0x3c,
	0x14, 0xfe, 0xb3, 0x6c, 0xd9, 0xea, 0xfe, 0xff, 0xb4, 0x79, 0x53, 0xff, 0x80, 0xa0, 0x54, 0x11,
	0x9a, 0x8a, 0x84, 0x36, 0x54, 0x04, 0x42, 0xbb, 0xeb, 0xda, 0x09, 0xca, 0xda, 0x52, 0x25, 0x65,
	0x48, 0xdc, 0x65, 0xa9, 0xdb, 0x5a, 0xa4, 0x76, 0xe5, 0xb8, 0x9b, 0xfa, 0x26, 0x5c, 0xf3, 0x06,
	0xbc, 0x05, 0x97, 0x3c, 0x02, 0x8c, 0x17, 0xe0, 0x11, 0xd0, 0xb1, 0x9d, 0x34, 0x1d, 0xed, 0x55,
	0x7b, 0xbe, 0xef, 0xf3, 0xf1, 0x67, 0x9f, 0x73, 0x1c, 0x74, 0x6f, 0x2a, 0xb8, 0xe4, 0x27, 0x11,
	0x67, 0x43, 0x3a, 0x32, 0x3f, 0xc7, 0x0a, 0xc3, 0x8e, 0x8e, 0xbc, 0xaf, 0x1b, 0xc8, 0x69, 0xa8,
	0xbf, 0xb8, 0x8c, 0x50, 0x33, 0x94, 0x61, 0x44, 0x98, 0x24, 0xc2, 0xb5, 0x2a, 0x56, 0xb5, 0xe0,
	0xe7, 0x10, 0xfc, 0x14, 0xed, 0xf7, 0x04, 0x9d, 0x84, 0x62, 0x9e, 0x93, 0x6d, 0x28, 0xd9, 0xdf,
	0x04, 0xbe, 0x8f, 0x76, 0xba, 0x7c, 0x40, 0xba, 0xe1, 0x84, 0xb8, 0xb6, 0x12, 0x65, 0x31, 0xae,
	0xa0, 0x62, 0x40, 0x46, 0x13, 0xc2, 0xa4, 0xa2, 0x37, 0x15, 0x9d, 0x87, 0xf0, 0x43, 0x64, 0xd7,
	0x1b, 0x6d, 0x77, 0xab, 0x62, 0x55, 0x8b, 0xb5, 0xe2, 0xb1, 0xb1, 0x5e, 0x6f, 0xb4, 0x7d, 0xc0,
	0xf1, 0x0b, 0x54, 0xac, 0xcf, 0x24, 0x3f, 0x67, 0x91, 0x98, 0x4f, 0xa5, 0xeb, 0x28, 0xd9, 0x41,
	0x26, 0x5b, 0x50, 0x7e, 0x5e, 0x87, 0x8f, 0x90, 0xf3, 0x9a, 0x27, 0x09, 0x9d, 0xba, 0xdb, 0x6a,
	0xc5, 0x6e, 0xba, 0x42, 0xa3, 0xbe, 0x61, 0x61, 0xf7, 0x7e, 0x3b, 0x70, 0x77, 0x96, 0x77, 0xef,
	0xb7, 0x03, 0x1f, 0x70, 0x6f, 0x98, 0xa6, 0xc1, 0xaf, 0x10, 0x32, 0xb9, 0x29, 0x67, 0xea, 0xca,
	0x8a, 0x35, 0x77, 0x39, 0xe9, 0x82, 0xf7, 0x73, 0x5a, 0xec, 0xa1, 0x7f, 0x7d, 0x22, 0xc5, 0xfc,
	0x2d, 0xa7, 0xac, 0x5d, 0xef, 0xba, 0x1b, 0x15, 0xbb, 0x5a, 0xf0, 0x97, 0x30, 0x4f, 0xa2, 0xbd,
	0xbb, 0x39, 0xf0, 0x1e, 0xb2, 0x2f, 0xc8, 0xdc, 0x54, 0x07, 0xfe, 0xe2, 0x23, 0xb4, 0x7b, 0x49,
	0x04, 0x1d, 0xce, 0x5b, 0x2c, 0xe2, 0x13, 0xca, 0x46, 0xaa, 0x26, 0x3b, 0xfe, 0x1d, 0x74, 0xa1,
	0x7b, 0x37, 0x93, 0x23, 0x0e, 0x3a, 0x3b, 0xaf, 0x4b, 0x51, 0xef, 0xa7, 0xa5, 0x4e, 0xbf, 0x42,
	0x6f, 0xad, 0xd2, 0xe3, 0x1a, 0x3a, 0xd4, 0x48, 0x40, 0xc4, 0x35, 0x11, 0x6f, 0x78, 0x22, 0x19,
	0x54, 0x55, 0xbb, 0x58, 0xc9, 0xc1, 0xe9, 0x1b, 0x74, 0x3a, 0x26, 0x22, 0x98, 0x51, 0x49, 0x12,
	0xd3, 0x20, 0x4b, 0x18, 0xb4, 0x63, 0x87, 0xb2, 0x4b, 0x22, 0x12, 0xb8, 0x5b, 0xdd, 0x23, 0x39,
	0x04, 0x9f, 0x22, 0xb7, 0x27, 0xc8, 0x90, 0x08, 0x9d, 0x7b, 0x29, 0xdf, 0x96, 0xda, 0x7b, 0x2d,
	0xef, 0x7d, 0xb1, 0x55, 0x7f, 0x61, 0x17, 0x6d, 0x9f, 0xb3, 0xf0, 0x2a, 0x26, 0x03, 0x73, 0xb8,
	0x34, 0xc4, 0x0f, 0x50, 0xa1, 0xc7, 0x63, 0x1a, 0xcd, 0xfb, 0xfd, 0xb6, 0x69, 0xf2, 0x05, 0x00,
	0xeb, 0x7c, 0x1e, 0x13, 0xe0, 0xb4, 0xf5, 0x34, 0x84, 0xb6, 0xef, 0xf3, 0x4f, 0x84, 0x01, 0xa5,
	0x3d, 0x67, 0xb1, 0x1a, 0x30, 0x7e, 0xc3, 0x74, 0x1a, 0xe5, 0x11, 0x06, 0x2c, 0x43, 0xf0, 0x63,
	0xf4, 0x5f, 0x93, 0x0c, 0xc3, 0x59, 0x2c, 0x8d, 0xc4, 0x51, 0x92, 0x65, 0x10, 0x3f, 0x43, 0x07,
	0xda, 0xe4, 0x05, 0x99, 0xb7, 0x69, 0x92, 0x6a, 0xb7, 0x95, 0xff, 0x55, 0x14, 0x7e, 0x82, 0x1c,
	0xe5, 0x21, 0x31, 0x1d, 0xbd, 0x9f, 0x9b, 0x27, 0x4d, 0xf8, 0x46, 0x00, 0x93, 0xd9, 0xa4, 0x89,
	0xba, 0x02, 0x38, 0x41, 0x41, 0x4f, 0x66, 0x0e, 0xc2, 0x2f, 0x51, 0x49, 0xef, 0xa1, 0x56, 0xf4,
	0xa0, 0x18, 0x89, 0x24, 0x2c, 0x22, 0x2e, 0x52, 0x0e, 0xd6, 0xb0, 0x60, 0xbb, 0x13, 0xf4, 0x4c,
	0xa6, 0x33, 0xce, 0x65, 0x22, 0x45, 0x38, 0x75, 0x8b, 0xda, 0xf6, 0x0a, 0xca, 0xfb, 0x6d, 0xa1,
	0x42, 0xe6, 0x10, 0x97, 0x90, 0xd3, 0x09, 0x93, 0xc5, 0xcb, 0x64, 0x22, 0x70, 0xec, 0x93, 0x69,
	0x4c, 0xa3, 0x50, 0xcd, 0xa0, 0x2e, 0x55, 0x1e, 0x02, 0x45, 0x7d, 0x44, 0x98, 0x34, 0xcb, 0x75,
	0xc1, 0xf2, 0x10, 0x94, 0xd3, 0xdc, 0xb1, 0xa9, 0x59, 0x1a, 0xe2, 0x43, 0xb4, 0xa5, 0x84, 0xa6,
	0x5a, 0x3a, 0xc0, 0x1f, 0x50, 0xa9, 0x13, 0xb2, 0x70, 0x44, 0x06, 0xd0, 0x5b, 0x34, 0x22, 0x3d,
	0xc1, 0xaf, 0xe9, 0x80, 0x08, 0xd7, 0xa9, 0xd8, 0xd5, 0x62, 0xed, 0x51, 0xee, 0x82, 0xef, 0x28,
	0xd4, 0x69, 0xfc, 0x35, 0xcb, 0xbd, 0xf7, 0xe8, 0xff, 0x35, 0x4b, 0xa0, 0x79, 0xea, 0x51, 0x44,
	0x92, 0x84, 0x8b, 0x56, 0x33, 0x7d, 0x9d, 0x17, 0x08, 0x34, 0x5e, 0x40, 0x22, 0x41, 0x64, 0xab,
	0x69, 0x2e, 0x21, 0x8b, 0x3d, 0xba, 0xf4, 0x5c, 0xc2, 0x1b, 0x02, 0xcf, 0x9b, 0xee, 0x78, 0x35,
	0xeb, 0x25, 0xe4, 0x34, 0xbb, 0x41, 0x90, 0xbd, 0x43, 0x26, 0x82, 0xe3, 0xb7, 0x7a, 0x00, 0xdb,
	0x0a, 0xd6, 0x01, 0x6c, 0x55, 0x8f, 0x63, 0x7e, 0x03, 0x49, 0x36, 0x55, 0x92, 0x2c, 0x3e, 0x3b,
	0xfd, 0x76, 0x5b, 0xb6, 0xbe, 0xdf, 0x96, 0xad, 0x1f, 0xb7, 0x65, 0xeb, 0xf3, 0xaf, 0xf2, 0x3f,
	0x1f, 0xab, 0x23, 0x2a, 0xc7, 0xb3, 0xab, 0xe3, 0x88, 0x4f, 0x4e, 0xc6, 0x61, 0x32, 0xa6, 0x11,
	0x17, 0x53, 0xf8, 0x18, 0x25, 0xb3, 0xf8, 0x24, 0xff, 0x81, 0xba, 0x72, 0x54, 0xf4, 0xfc, 0x4f,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x6e, 0x95, 0x34, 0xb9, 0xb7, 0x06, 0x00, 0x00,
}

func (m *Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Config) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Datacenter) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.Datacenter)))
		i += copy(dAtA[i:], m.Datacenter)
	}
	if len(m.PrimaryDatacenter) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.PrimaryDatacenter)))
		i += copy(dAtA[i:], m.PrimaryDatacenter)
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	if len(m.SegmentName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.SegmentName)))
		i += copy(dAtA[i:], m.SegmentName)
	}
	if m.ACL != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.ACL.Size()))
		n1, err := m.ACL.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.AutoEncrypt != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.AutoEncrypt.Size()))
		n2, err := m.AutoEncrypt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Gossip != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.Gossip.Size()))
		n3, err := m.Gossip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.TLS != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.TLS.Size()))
		n4, err := m.TLS.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Gossip) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Gossip) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Encryption != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.Encryption.Size()))
		n5, err := m.Encryption.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.RetryJoinLAN) > 0 {
		for _, s := range m.RetryJoinLAN {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GossipEncryption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GossipEncryption) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.VerifyIncoming {
		dAtA[i] = 0x10
		i++
		if m.VerifyIncoming {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.VerifyOutgoing {
		dAtA[i] = 0x18
		i++
		if m.VerifyOutgoing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TLS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLS) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VerifyOutgoing {
		dAtA[i] = 0x8
		i++
		if m.VerifyOutgoing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.VerifyServerHostname {
		dAtA[i] = 0x10
		i++
		if m.VerifyServerHostname {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.CipherSuites) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.CipherSuites)))
		i += copy(dAtA[i:], m.CipherSuites)
	}
	if len(m.MinVersion) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.MinVersion)))
		i += copy(dAtA[i:], m.MinVersion)
	}
	if m.PreferServerCipherSuites {
		dAtA[i] = 0x28
		i++
		if m.PreferServerCipherSuites {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ACL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ACL) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enabled {
		dAtA[i] = 0x8
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PolicyTTL) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.PolicyTTL)))
		i += copy(dAtA[i:], m.PolicyTTL)
	}
	if len(m.RoleTTL) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.RoleTTL)))
		i += copy(dAtA[i:], m.RoleTTL)
	}
	if len(m.TokenTTL) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.TokenTTL)))
		i += copy(dAtA[i:], m.TokenTTL)
	}
	if len(m.DownPolicy) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.DownPolicy)))
		i += copy(dAtA[i:], m.DownPolicy)
	}
	if len(m.DefaultPolicy) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.DefaultPolicy)))
		i += copy(dAtA[i:], m.DefaultPolicy)
	}
	if m.EnableKeyListPolicy {
		dAtA[i] = 0x38
		i++
		if m.EnableKeyListPolicy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Tokens != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintConfig(dAtA, i, uint64(m.Tokens.Size()))
		n6, err := m.Tokens.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.DisabledTTL) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.DisabledTTL)))
		i += copy(dAtA[i:], m.DisabledTTL)
	}
	if m.EnableTokenPersistence {
		dAtA[i] = 0x50
		i++
		if m.EnableTokenPersistence {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MSPDisableBootstrap {
		dAtA[i] = 0x58
		i++
		if m.MSPDisableBootstrap {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ACLTokens) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ACLTokens) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Master) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.Master)))
		i += copy(dAtA[i:], m.Master)
	}
	if len(m.Replication) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.Replication)))
		i += copy(dAtA[i:], m.Replication)
	}
	if len(m.AgentMaster) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.AgentMaster)))
		i += copy(dAtA[i:], m.AgentMaster)
	}
	if len(m.Default) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.Default)))
		i += copy(dAtA[i:], m.Default)
	}
	if len(m.Agent) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.Agent)))
		i += copy(dAtA[i:], m.Agent)
	}
	if len(m.ManagedServiceProvider) > 0 {
		for _, msg := range m.ManagedServiceProvider {
			dAtA[i] = 0x32
			i++
			i = encodeVarintConfig(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ACLServiceProviderToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ACLServiceProviderToken) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccessorID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.AccessorID)))
		i += copy(dAtA[i:], m.AccessorID)
	}
	if len(m.SecretID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintConfig(dAtA, i, uint64(len(m.SecretID)))
		i += copy(dAtA[i:], m.SecretID)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AutoEncrypt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoEncrypt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TLS {
		dAtA[i] = 0x8
		i++
		if m.TLS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.DNSSAN) > 0 {
		for _, s := range m.DNSSAN {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.IPSAN) > 0 {
		for _, s := range m.IPSAN {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.AllowTLS {
		dAtA[i] = 0x20
		i++
		if m.AllowTLS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintConfig(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Datacenter)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.PrimaryDatacenter)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.SegmentName)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.ACL != nil {
		l = m.ACL.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.AutoEncrypt != nil {
		l = m.AutoEncrypt.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.Gossip != nil {
		l = m.Gossip.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.TLS != nil {
		l = m.TLS.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Gossip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Encryption != nil {
		l = m.Encryption.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if len(m.RetryJoinLAN) > 0 {
		for _, s := range m.RetryJoinLAN {
			l = len(s)
			n += 1 + l + sovConfig(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GossipEncryption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.VerifyIncoming {
		n += 2
	}
	if m.VerifyOutgoing {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VerifyOutgoing {
		n += 2
	}
	if m.VerifyServerHostname {
		n += 2
	}
	l = len(m.CipherSuites)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.MinVersion)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.PreferServerCipherSuites {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ACL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.PolicyTTL)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.RoleTTL)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.TokenTTL)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.DownPolicy)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.DefaultPolicy)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.EnableKeyListPolicy {
		n += 2
	}
	if m.Tokens != nil {
		l = m.Tokens.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.DisabledTTL)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.EnableTokenPersistence {
		n += 2
	}
	if m.MSPDisableBootstrap {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ACLTokens) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Master)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.Replication)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.AgentMaster)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.Default)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.Agent)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	if len(m.ManagedServiceProvider) > 0 {
		for _, e := range m.ManagedServiceProvider {
			l = e.Size()
			n += 1 + l + sovConfig(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ACLServiceProviderToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccessorID)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.SecretID)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AutoEncrypt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TLS {
		n += 2
	}
	if len(m.DNSSAN) > 0 {
		for _, s := range m.DNSSAN {
			l = len(s)
			n += 1 + l + sovConfig(uint64(l))
		}
	}
	if len(m.IPSAN) > 0 {
		for _, s := range m.IPSAN {
			l = len(s)
			n += 1 + l + sovConfig(uint64(l))
		}
	}
	if m.AllowTLS {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovConfig(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozConfig(x uint64) (n int) {
	return sovConfig(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datacenter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datacenter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryDatacenter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryDatacenter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SegmentName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ACL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ACL == nil {
				m.ACL = &ACL{}
			}
			if err := m.ACL.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoEncrypt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoEncrypt == nil {
				m.AutoEncrypt = &AutoEncrypt{}
			}
			if err := m.AutoEncrypt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gossip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gossip == nil {
				m.Gossip = &Gossip{}
			}
			if err := m.Gossip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TLS == nil {
				m.TLS = &TLS{}
			}
			if err := m.TLS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Gossip) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Gossip: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Gossip: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encryption == nil {
				m.Encryption = &GossipEncryption{}
			}
			if err := m.Encryption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryJoinLAN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetryJoinLAN = append(m.RetryJoinLAN, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GossipEncryption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GossipEncryption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GossipEncryption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyIncoming", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VerifyIncoming = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyOutgoing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VerifyOutgoing = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TLS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TLS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyOutgoing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VerifyOutgoing = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyServerHostname", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VerifyServerHostname = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherSuites", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CipherSuites = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreferServerCipherSuites", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreferServerCipherSuites = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ACL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ACL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ACL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyTTL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyTTL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleTTL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleTTL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenTTL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenTTL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableKeyListPolicy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableKeyListPolicy = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tokens == nil {
				m.Tokens = &ACLTokens{}
			}
			if err := m.Tokens.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisabledTTL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisabledTTL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableTokenPersistence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableTokenPersistence = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MSPDisableBootstrap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MSPDisableBootstrap = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ACLTokens) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ACLTokens: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ACLTokens: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Master", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Master = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replication", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replication = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentMaster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgentMaster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Default = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Agent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Agent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagedServiceProvider", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagedServiceProvider = append(m.ManagedServiceProvider, &ACLServiceProviderToken{})
			if err := m.ManagedServiceProvider[len(m.ManagedServiceProvider)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ACLServiceProviderToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ACLServiceProviderToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ACLServiceProviderToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessorID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessorID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoEncrypt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoEncrypt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoEncrypt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TLS = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNSSAN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DNSSAN = append(m.DNSSAN, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPSAN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPSAN = append(m.IPSAN, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowTLS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowTLS = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipConfig(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthConfig
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthConfig
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowConfig
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipConfig(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthConfig
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthConfig = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowConfig   = fmt.Errorf("proto: integer overflow")
)
